# Практичне заняття №8
## Завдання 1
### Умова
Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

### Рішення
write() може повернути менше байтів, ніж вимагається, в таких випадках як запис у неблокуючий дескриптор (O_NONBLOCK) — наприклад у pipe, як у моєму варіанті вирішення, через системні обмеження, якщо сигнал перервав операцію, або при записі у термінал, драйвер або FIFO.

Я написала простий приклад, де write повертає нам значення відмінне від nbytes, а саме -1, але ситуація оброблюється коректно.
В моєму випадку створюється pipe і далі я переводжу його в неблокуючий режим (O_NONBLOCK). Потім у циклі записуємо в нього дані. Коли буфер переповнюється write() повертає менше байтів, ніж було запрошено (наприклад, 2048 замість 4096), або повертає -1 з errno == EAGAIN, що означає що буфер заповнено, зараз запис неможливий без блокування.
Як результат, отримуємо варіант, коли errno = EAGAIN

![image](https://github.com/user-attachments/assets/12b3bfcd-6c2f-4f5a-a061-50ad99d7928f)

Для того аби побачити випадок частковоо запису використовуючи мою програму, варто виконати такі кроки:
1) Зробити буфер більшим
2) У циклі замість break після часткового запису — продовжити запис, щоб побачити кілька таких ситуацій.
3) Перед записом перевірити, скільки байтів ще можна записати.

Частковий запис виникає тільки один раз — у момент, коли в pipe залишилося місця менше ніж на один блок (4096 наприклад), але ще більше ніж 0.
Наприклад: залишилось 2048 байтів у буфері pipe, тому write() запише 2048 з 4096.

## Завдання 2
### Умова
Є файл, дескриптор якого — fd. Файл містить таку послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. У програмі виконується наступна послідовність системних викликів:
lseek(fd, 3, SEEK_SET);
read(fd, &buffer, 4);
де виклик lseek переміщує покажчик на третій байт файлу. Що буде містити буфер після завершення виклику read? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

### Рішення
Системний виклик
```
lseek(fd, 3, SEEK_SET);
```
означає перемістити покажчик читання у файлі на позицію 3 (нумерація з 0).
А
```
read(fd, &buffer, 4);
```
означає прочитати 4 байти з позиції 3.
Побудуємо умовну табличку для кразої візуалізації:
Index  |  Value
  0         4
  1         5
  2         2  
  3         2  <-- lseek встновлюємо сюди
  4         3
  5         3
  6         7
 ...       ...

 Тобто після таких маніпуляцій буфер буде містити всі значення після встановлення lseek: 2, 3, 3, 7..
Програма демонструє цю ж відповідь, у результаті маємо вивід:

![image](https://github.com/user-attachments/assets/a2e85d96-5884-4e81-9eb6-775ed1006724)

## Завдання 3
### Умова
Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

### Рішення
Бібліотечна функція qsort() зазвичай використовує реалізацію quicksort, яка має середню складність O(n log n). 
Я написала тестовий код для автоматизації пошуку найгіршого підбору чисел для функції qsort(), де порівнювала швидкість сортування у секундах та кількість порівнянь.
Програма складається з декількох функцій:
1) Функція порівняння: функція порівняння для qsort, працює з числами типу int, а також підраховує кількість порівнянь для аналізу складності.
2) Функція для генерації чисел у спадному порядку
3) Функція для генерації чисел у зростаючому порядку
4) Функція для генерації масиву однакових чисел
5) Функція для генерації масиву рандомних чисел
6) Функція test_case: cтворює масив з n елементів, заповнює його даними за допомогою переданої функції-генератора (generator), вимірює час і кількість порівнянь під час сортування qsort, виводить ім'я тесту, кількість порівнянь та час сортування. Основна функція для цієї програми.
7) Функція main - ініціалізує генератор випадкових чисел, встановлює розмір масиву n = MAX_N, послідовно викликає test_case для всіх передбачених випадків масивів

Потім я ще додала дві функції для тестування правильності qsort.
1) assert_sorted - допоміжна функція, яка перевіряє, чи масив відсортований за зростанням. Якщо знаходиться порушення, програма завершує виконання з відповідним повідомленням.
2) test_correctness() - перевіряє роботу qsort на спеціально підібраних маленьких масивах, кожен масив сортується і перевіряється через assert_sorted.

Коли я поставила макрозмінну MAX_N 10000, то це число виявилось надто малим, щоб побачити хоч несуттєву різницю в часі сортування. Результатами були нулі.
Але потім я збільшила це число до 500 000, і зараз можна спостерігати такий результат:

![image](https://github.com/user-attachments/assets/619b7591-769a-440e-89a7-95d6e967ddd7)

Проаналізувавши отримані результати, можна сказати, що найгірший випадок чисел був з масивом рандомних чисел, а найкращий - масив з однаковими значеннми. 

## Завдання 4
### Умова
 Виконайте наступну програму на мові програмування С:
 ```
int main() {
  int pid;
  pid = fork();
  printf("%d\n", pid);
}
```
Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?

### Рішення
При запуску запропонованого варіанту програми отримаємо:

![image](https://github.com/user-attachments/assets/f000ca89-ec43-4527-b500-8355042fb697)

де 1078 - це PID дочірнього процесу у батьківському, а 0 - у дочірньому.
Отже, обидва процеси виконають printf("%d\n", pid);, але з різними значеннями pid.
Якщо fork() не вдався — повертається -1. Обробимо цю ситуацію та додамо трохи пояснень до виводу.

![image](https://github.com/user-attachments/assets/52602329-a823-42ef-9c7c-526c3b81c011)

Це виглядає так само, хіба що трохи гарніше. 
Припускаючи, що виклик fork() був успішним, результат виконання програми може бути таким як ми отримали, тобто вивід PID-ів у порядку:
1095
0
або також вивід цих самих PID-ів, але в іншому порядку, тобто:
0 
1095
Причиною цього є те, що процеси виконуються паралельно. 

## Індивідувальне завдання
### Умова
Дослідіть поведінку write() при записі у FIFO, коли читачів немає, і поясніть результат.

### Рішення
Якщо говорити про теорію, то:
FIFO  — це спеціальний файл, який дозволяє обмінюватися даними між процесами.
Поводиться як звичайний файл, але якщо немає жодного процесу, який читає FIFO, і інший процес виконує write(), то:

a) write() завершується з помилкою і повертає -1

b) errno == EPIPE (немає читача)

c) Сигнал SIGPIPE надсилається процесу-записувачу (за замовчуванням завершує процес)

Спочатку створимо тестовий FIFO командою:
```
mkfifo fifofile
```
Перша версія написаної програми працювала наступним чином:

![image](https://github.com/user-attachments/assets/c11d2b9c-5307-4393-bf1f-21ef13eee3fb)

Я подумала що воно просто зависло, але виявилось, що через те, що я використала open("myfifo", O_WRONLY) без O_NONBLOCK, FIFO блокується, поки немає жодного процесу, який відкрив FIFO на читання і нормальна поведінка FIFO, бо вона чекає на з'єднання з іншим кінцем (читачем).

Але потім я додала прапорець O_NONBLOCK та отримала більш інформативний вивід:

![image](https://github.com/user-attachments/assets/2e5755ad-cb39-42b3-b967-82310920e31e)

Якщо вказати O_NONBLOCK при відкритті або доступі до файлу, системні виклики не блокуються, навіть якщо зазвичай чекали б на подію (наприклад, з’явлення читача чи записувача як в нашому випадку).
